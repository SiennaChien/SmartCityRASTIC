def set_map(self, ID):
    if ID == "limo770":
        #coordinates of every critical point
        self.lane_width = 450
        self.pt_a = (2933, -1980)
        self.pt_b = (3044, 2536)
        self.pt_c = (1922, -1977)
        self.pt_d = (1825, -652)
        self.pt_e = (2040, 2519)
        self.pt_f = (683, 2536)
        self.pt_g = (153, 287)
        self.pt_h = (413, 688)
        self.pt_i = (1560, -1945)
        self.pt_j = (-2017, -1933)
        self.pt_k = (-2003, 255)
        self.pt_l = (-2021, 823)
        self.pt_m = (-2006, 2597)
        self.pt_n = (-2412, -1788)
        self.pt_o = (-2402, 121)
        self.pt_p = (-2546, 686)
        self.pt_q = (-2408, 2522)
        self.pt_r = (-4683, -1980)
        self.pt_s = (-4737, 261)
        self.pt_t = (-4578, 683)
        self.pt_u = (-4660, 2654)

        #data points that characterize each circle for the corners - center x, center y, radius. Each variable is a tuple (A, B, C)
        self.circle_a = (self.pt_a[0] - self.lane_width, self.pt_a[1] + self.lane_width, self.lane_width/1.3)
        self.circle_b = (self.pt_b[0] - self.lane_width, self.pt_b[1] - self.lane_width, self.lane_width/1.5)
        self.circle_c = (self.pt_c[0] + self.lane_width, self.pt_c[1] + self.lane_width, self.lane_width/1.5)
        self.circle_d = (self.pt_d[0] + self.lane_width, self.pt_d[1] - self.lane_width, self.lane_width) #in practice this is not use
        self.circle_e = (self.pt_e[0] + self.lane_width, self.pt_e[1] - self.lane_width, self.lane_width/1.5)
        self.circle_f = (self.pt_f[0] + self.lane_width, self.pt_f[1] - self.lane_width, self.lane_width/2)
        self.circle_g = (self.pt_d[0] - self.lane_width, self.pt_d[1] - self.lane_width, self.lane_width)
        self.circle_h = (self.pt_h[0] - self.lane_width, self.pt_h[1] - self.lane_width, self.lane_width)
        self.circle_i = (self.pt_i[0] + self.lane_width, self.pt_i[1] + self.lane_width, self.lane_width)
        self.circle_j = (self.pt_j[0] + self.lane_width, self.pt_j[1] + self.lane_width, self.lane_width)
        self.circle_k = (self.pt_k[0] + self.lane_width*2.5, self.pt_k[1] - self.lane_width*2, self.lane_width*2)
        self.circle_l = (self.pt_l[0] + self.lane_width*2.8, self.pt_l[1] + self.lane_width*2, self.lane_width*2)
        self.circle_m = (self.pt_m[0] + self.lane_width, self.pt_m[1] - self.lane_width, self.lane_width)
        self.circle_n = (self.pt_n[0] - self.lane_width, self.pt_n[1] + self.lane_width, self.lane_width)
        self.circle_o = (self.pt_o[0] - self.lane_width*2.5, self.pt_o[1] - self.lane_width*2, self.lane_width*2)
        self.circle_p = (self.pt_p[0] - self.lane_width*2.2, self.pt_p[1] + self.lane_width*2.2, self.lane_width*1.9) #smaller multiplier to x increases x & decrease the multiplier to increase z
        self.circle_q = (self.pt_q[0] - self.lane_width, self.pt_q[1] - self.lane_width, self.lane_width)
        self.circle_r = (self.pt_r[0] + self.lane_width, self.pt_r[1] + self.lane_width, self.lane_width)
        self.circle_s = (self.pt_s[0] + self.lane_width, self.pt_s[1] - self.lane_width, self.lane_width)
        self.circle_t = (self.pt_t[0] + self.lane_width, self.pt_t[1] + self.lane_width, self.lane_width)
        self.circle_u = (self.pt_u[0] + self.lane_width, self.pt_u[1] - self.lane_width, self.lane_width)

        #the ranges near each corner that activates the circle path for the limo to follow
        self.act_range_a = (self.lane_width * 1, self.lane_width / 1.7)
        self.act_range_b = (self.lane_width * 0.8, self.lane_width * 1)
        self.act_range_c = (self.lane_width / 1, self.lane_width * 1)
        self.act_range_d = (self.lane_width * 0.7, self.lane_width * 0.5)
        self.act_range_e = (self.lane_width * 1, self.lane_width * 0.8)
        self.act_range_f = (self.lane_width * 1, self.lane_width*1.2)
        self.act_range_g = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_h = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_i = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_j = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_k = (self.lane_width * 1.5, self.lane_width * 1.5)
        self.act_range_l = (self.lane_width *1.2, self.lane_width *1.2)
        self.act_range_m = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_n = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_o = (self.lane_width * 1.4, self.lane_width * 1.4)
        self.act_range_p = (self.lane_width * 1.25, self.lane_width * 1.25)
        self.act_range_q = (self.lane_width * 1.3, self.lane_width * 1.3)
        self.act_range_r = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_s = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_t = (self.lane_width * 1.3, self.lane_width * 1.3)
        self.act_range_u = (self.lane_width * 1, self.lane_width * 1)

        #values of each line, each element is a tuple (kp, ki, kd)
        self.path_A_PID = (0.002, 0.00005, 0.003)
        self.path_B_PID = (0.0008, 0.00008, 0.003)
        self.path_C_PID = (0.0008, 0.00008, 0.005)
        self.path_D_PID = (0.0002, 0.00005, 0.001)
        self.path_D2_PID = (0.0007, 0.00008, 0.001)
        self.path_E_PID = (0.0005, 0.00003, 0.003)
        self.path_F_PID = (0.0008, 0.00008, 0.003)
        self.path_G_PID = (0.0009, 0.00006, 0.0005)
        self.path_H_PID = (-0.001, -0.00003, -0.001)
        self.path_I_PID = (-0.0011, -0.000099, -0.0009)
        self.path_J_PID = (0.001, 0.00009, 0.0008)
        self.path_K_PID = (0.0008, 0.00008, 0.003)

        #PID values of each circle, each element is a tuple (kp, ki, kd)
        self.circle_a_PID = (-0.7, -0.00045, -0.050)
        self.circle_b_PID = (-0.55, -0.00045, -0.037)
        self.circle_c_PID = (-0.56, -0.00045, -0.037)
        self.circle_d_PID = (-0.0005, -0.00045, -0.003)
        self.circle_e_PID = (-0.0030, -0.000045, -0.0017)
        self.circle_f_PID = (-0.050, -0.00045, -0.037)
        self.circle_g_PID = (-0.050, -0.00045, -0.037)
        self.circle_h_PID = (-0.050, -0.00045, -0.037)
        self.circle_i_PID = (-0.050, -0.045, -0.037)
        self.circle_j_PID = (-0.050, -0.00045, -0.037)
        self.circle_k_PID = (-0.02, -0.00015, -0.037)
        self.circle_l_PID = (-0.022, -0.03, -0.01)
        self.circle_m_PID = (-0.050, -0.00045, -0.037)
        self.circle_n_PID = (-0.050, -0.00045, -0.037)
        self.circle_o_PID = (-0.050, -0.00045, -0.037)
        self.circle_p_PID = (-0.080, -0.006, -0.007)
        self.circle_q_PID = (-0.050, -0.00045, -0.037)
        self.circle_r_PID = (-0.050, -0.00045, -0.037)
        self.circle_s_PID = (-0.050, -0.00045, -0.037)
        self.circle_t_PID = (-0.050, -0.00045, -0.037)
        self.circle_u_PID = (-0.050, -0.00045, -0.037)

    if ID == "limo155":
        #coordinates of every critical point
        self.lane_width = 450
        self.pt_a = (2933, -1980)
        self.pt_b = (3044, 2536)
        self.pt_c = (1922, -1977)
        self.pt_d = (1825, -652)
        self.pt_e = (2040, 2519)
        self.pt_f = (683, 2536)
        self.pt_g = (153, 287)
        self.pt_h = (413, 688)
        self.pt_i = (1560, -1945)
        self.pt_j = (-2017, -1933)
        self.pt_k = (-2003, 255)
        self.pt_l = (-2021, 823)
        self.pt_m = (-2006, 2597)
        self.pt_n = (-2412, -1788)
        self.pt_o = (-2402, 121)
        self.pt_p = (-2546, 686)
        self.pt_q = (-2413, 2528)
        self.pt_r = (-4683, -1980)
        self.pt_s = (-4737, 261)
        self.pt_t = (-4578, 683)
        self.pt_u = (-4660, 2654)

        #data points that characterize each circle for the corners - center x, center y, radius. Each variable is a tuple (A, B, C)
        self.circle_a = (self.pt_a[0] - self.lane_width, self.pt_a[1] + self.lane_width, self.lane_width/1.3)
        self.circle_b = (self.pt_b[0] - self.lane_width, self.pt_b[1] - self.lane_width, self.lane_width/1.5)
        self.circle_c = (self.pt_c[0] + self.lane_width, self.pt_c[1] + self.lane_width, self.lane_width/1.5)
        self.circle_d = (self.pt_d[0] + self.lane_width, self.pt_d[1] - self.lane_width, self.lane_width) #in practice this is not use
        self.circle_e = (self.pt_e[0] + self.lane_width, self.pt_e[1] - self.lane_width, self.lane_width/1.5)
        self.circle_f = (self.pt_f[0] + self.lane_width, self.pt_f[1] - self.lane_width, self.lane_width/2)
        self.circle_g = (self.pt_d[0] - self.lane_width, self.pt_d[1] - self.lane_width, self.lane_width)
        self.circle_h = (self.pt_h[0] - self.lane_width, self.pt_h[1] - self.lane_width, self.lane_width)
        self.circle_i = (self.pt_i[0] + self.lane_width, self.pt_i[1] + self.lane_width, self.lane_width)
        self.circle_j = (self.pt_j[0] + self.lane_width, self.pt_j[1] + self.lane_width, self.lane_width)
        self.circle_k = (self.pt_k[0] + self.lane_width*2.8, self.pt_k[1] - self.lane_width*2, self.lane_width*2)
        self.circle_l = (self.pt_l[0] + self.lane_width*2.6, self.pt_l[1] + self.lane_width*2.1, self.lane_width*1.9)
        self.circle_m = (self.pt_m[0] + self.lane_width, self.pt_m[1] - self.lane_width, self.lane_width)
        self.circle_n = (self.pt_n[0] - self.lane_width, self.pt_n[1] + self.lane_width, self.lane_width)
        self.circle_o = (self.pt_o[0] - self.lane_width*2.5, self.pt_o[1] - self.lane_width*2, self.lane_width*2)
        self.circle_p = (self.pt_p[0] - self.lane_width*2.2, self.pt_p[1] + self.lane_width*2.2, self.lane_width*1.9) #smaller multiplier to x increases x & decrease the multiplier to increase z
        self.circle_q = (self.pt_q[0] - self.lane_width, self.pt_q[1] - self.lane_width, self.lane_width)
        self.circle_r = (self.pt_r[0] + self.lane_width, self.pt_r[1] + self.lane_width, self.lane_width)
        self.circle_s = (self.pt_s[0] + self.lane_width, self.pt_s[1] - self.lane_width, self.lane_width)
        self.circle_t = (self.pt_t[0] + self.lane_width, self.pt_t[1] + self.lane_width, self.lane_width)
        self.circle_u = (self.pt_u[0] + self.lane_width, self.pt_u[1] - self.lane_width, self.lane_width)

        #the ranges near each corner that activates the circle path for the limo to follow
        self.act_range_a = (self.lane_width * 1, self.lane_width / 1.7)
        self.act_range_b = (self.lane_width * 0.8, self.lane_width * 1)
        self.act_range_c = (self.lane_width / 1, self.lane_width * 1)
        self.act_range_d = (self.lane_width * 0.7, self.lane_width * 0.5)
        self.act_range_e = (self.lane_width * 1, self.lane_width * 0.8)
        self.act_range_f = (self.lane_width * 1, self.lane_width*1.2)
        self.act_range_g = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_h = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_i = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_j = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_k = (self.lane_width * 1.5, self.lane_width * 1.5)
        self.act_range_l = (self.lane_width *1.4, self.lane_width *1.4)
        self.act_range_m = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_n = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_o = (self.lane_width * 1.4, self.lane_width * 1.4)
        self.act_range_p = (self.lane_width * 1.25, self.lane_width * 1.25)
        self.act_range_q = (self.lane_width * 1.3, self.lane_width * 1.3)
        self.act_range_r = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_s = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_t = (self.lane_width * 1.3, self.lane_width * 1.3)
        self.act_range_u = (self.lane_width * 1, self.lane_width * 1)


        #values of each line, each element is a tuple (kp, ki, kd)
        self.path_A_PID = (0.002, 0.00005, 0.003)
        self.path_B_PID = (0.0008, 0.00008, 0.003)
        self.path_C_PID = (0.0008, 0.00008, 0.005)
        self.path_D_PID = (0.0002, 0.00005, 0.001)
        self.path_D2_PID = (0.0007, 0.00008, 0.001)
        self.path_E_PID = (0.0005, 0.00003, 0.003)
        self.path_F_PID = (0.0008, 0.00008, 0.003)
        self.path_G_PID = (0.0008, 0.00004, 0.001)
        self.path_H_PID = (-0.001, -0.00003, -0.001)
        self.path_I_PID = (-0.0008, -0.00006, -0.0006)
        self.path_J_PID = (0.001, 0.00009, 0.0008)
        self.path_K_PID = (0.0008, 0.00008, 0.003)

        #PID values of each circle, each element is a tuple (kp, ki, kd)
        self.circle_a_PID = (-0.7, -0.00045, -0.050)
        self.circle_b_PID = (-0.55, -0.00045, -0.037)
        self.circle_c_PID = (-0.56, -0.00045, -0.037)
        self.circle_d_PID = (-0.0005, -0.00045, -0.003)
        self.circle_e_PID = (-0.0030, -0.000045, -0.0017)
        self.circle_f_PID = (-0.050, -0.00045, -0.037)
        self.circle_g_PID = (-0.050, -0.00045, -0.037)
        self.circle_h_PID = (-0.050, -0.00045, -0.037)
        self.circle_i_PID = (-0.050, -0.00045, -0.037)
        self.circle_j_PID = (-0.050, -0.00045, -0.037)
        self.circle_k_PID = (-0.06, -0.00015, -0.01)
        self.circle_l_PID = (-0.022, -0.03, -0.01)
        self.circle_m_PID = (-0.050, -0.00045, -0.037)
        self.circle_n_PID = (-0.050, -0.00045, -0.037)
        self.circle_o_PID = (-0.050, -0.00045, -0.037)
        self.circle_p_PID = (-0.080, -0.02, -0.01)
        self.circle_q_PID = (-0.050, -0.009, -0.01)
        self.circle_r_PID = (-0.050, -0.00045, -0.037)
        self.circle_s_PID = (-0.050, -0.00045, -0.037)
        self.circle_t_PID = (-0.050, -0.00045, -0.037)
        self.circle_u_PID = (-0.050, -0.00045, -0.037)

    if ID == "limo789":
        #coordinates of every critical point
        self.lane_width = 450
        self.pt_a = (2933, -1980)
        self.pt_b = (3044, 2536)
        self.pt_c = (1922, -1977)
        self.pt_d = (1825, -652)
        self.pt_e = (2040, 2519)
        self.pt_f = (683, 2536)
        self.pt_g = (30, 270)
        self.pt_h = (413, 688)
        self.pt_i = (1560, -1945)
        self.pt_j = (-2017, -1933)
        self.pt_k = (-2003, 255)
        self.pt_l = (-2021, 823)
        self.pt_m = (-2006, 2597)
        self.pt_n = (-2412, -1788)
        self.pt_o = (-2402, 121)
        self.pt_p = (-2546, 686)
        self.pt_q = (-2408, 2522)
        self.pt_r = (-4683, -1980)
        self.pt_s = (-4668, 274)
        self.pt_t = (-4578, 683)
        self.pt_u = (-4660, 2654)

        #data points that characterize each circle for the corners - center x, center y, radius. Each variable is a tuple (A, B, C)
        self.circle_a = (self.pt_a[0] - self.lane_width, self.pt_a[1] + self.lane_width, self.lane_width/1.3)
        self.circle_b = (self.pt_b[0] - self.lane_width, self.pt_b[1] - self.lane_width, self.lane_width/1.5)
        self.circle_c = (self.pt_c[0] + self.lane_width, self.pt_c[1] + self.lane_width, self.lane_width/1.5)
        self.circle_d = (self.pt_d[0] + self.lane_width, self.pt_d[1] - self.lane_width, self.lane_width) #in practice this is not use
        self.circle_e = (self.pt_e[0] + self.lane_width, self.pt_e[1] - self.lane_width, self.lane_width/1.5)
        self.circle_f = (self.pt_f[0] + self.lane_width, self.pt_f[1] - self.lane_width, self.lane_width/2)
        self.circle_g = (self.pt_d[0] - self.lane_width, self.pt_d[1] - self.lane_width, self.lane_width)
        self.circle_h = (self.pt_h[0] - self.lane_width, self.pt_h[1] - self.lane_width, self.lane_width)
        self.circle_i = (self.pt_i[0] + self.lane_width, self.pt_i[1] + self.lane_width, self.lane_width)
        self.circle_j = (self.pt_j[0] + self.lane_width, self.pt_j[1] + self.lane_width, self.lane_width)
        self.circle_k = (self.pt_k[0] + self.lane_width*2.8, self.pt_k[1] - self.lane_width*2, self.lane_width*1.9)
        self.circle_l = (self.pt_l[0] + self.lane_width*2.8, self.pt_l[1] + self.lane_width*2, self.lane_width*2)
        self.circle_m = (self.pt_m[0] + self.lane_width, self.pt_m[1] - self.lane_width, self.lane_width)
        self.circle_n = (self.pt_n[0] - self.lane_width, self.pt_n[1] + self.lane_width, self.lane_width)
        self.circle_o = (self.pt_o[0] - self.lane_width*2.5, self.pt_o[1] - self.lane_width*2, self.lane_width*2)
        self.circle_p = (self.pt_p[0] - self.lane_width*2.3, self.pt_p[1] + self.lane_width*2.3, self.lane_width*1.9) #smaller multiplier to x increases x & decrease the multiplier to increase z
        self.circle_q = (self.pt_q[0] - self.lane_width, self.pt_q[1] - self.lane_width, self.lane_width)
        self.circle_r = (self.pt_r[0] + self.lane_width, self.pt_r[1] + self.lane_width, self.lane_width)
        self.circle_s = (self.pt_s[0] + self.lane_width, self.pt_s[1] - self.lane_width, self.lane_width)
        self.circle_t = (self.pt_t[0] + self.lane_width, self.pt_t[1] + self.lane_width, self.lane_width)
        self.circle_u = (self.pt_u[0] + self.lane_width, self.pt_u[1] - self.lane_width, self.lane_width)

        #the ranges near each corner that activates the circle path for the limo to follow
        self.act_range_a = (self.lane_width * 1, self.lane_width / 1.7)
        self.act_range_b = (self.lane_width * 0.8, self.lane_width * 1)
        self.act_range_c = (self.lane_width / 1, self.lane_width * 1)
        self.act_range_d = (self.lane_width * 0.7, self.lane_width * 0.5)
        self.act_range_e = (self.lane_width * 1, self.lane_width * 0.8)
        self.act_range_f = (self.lane_width * 1, self.lane_width*1.2)
        self.act_range_g = (self.lane_width * 1.4, self.lane_width * 1.4)
        self.act_range_h = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_i = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_j = (self.lane_width * 1.4, self.lane_width * 1.4)
        self.act_range_k = (self.lane_width * 1.45, self.lane_width * 1.45)
        self.act_range_l = (self.lane_width *1.3, self.lane_width *1.3)
        self.act_range_m = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_n = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_o = (self.lane_width * 1.4, self.lane_width * 1.4)
        self.act_range_p = (self.lane_width * 1.25, self.lane_width * 1.25)
        self.act_range_q = (self.lane_width * 1.3, self.lane_width * 1.3)
        self.act_range_r = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_s = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_t = (self.lane_width * 1.3, self.lane_width * 1.3)
        self.act_range_u = (self.lane_width * 1, self.lane_width * 1)

        #values of each line, each element is a tuple (kp, ki, kd)
        self.path_A_PID = (0.002, 0.00005, 0.003)
        self.path_B_PID = (0.0008, 0.00008, 0.003)
        self.path_C_PID = (0.0008, 0.00008, 0.005)
        self.path_D_PID = (0.0002, 0.00005, 0.001)
        self.path_D2_PID = (0.0007, 0.00008, 0.001)
        self.path_E_PID = (0.0005, 0.00003, 0.003)
        self.path_F_PID = (0.0008, 0.00008, 0.003)
        self.path_G_PID =(0.0003, 0.00011, 0.0009)
        self.path_H_PID = (-0.0008, -0.0007, -0.001)
        self.path_I_PID =   (-0.001, -0.0009, -0.001)
        self.path_J_PID = (0.0018, 0.00010, 0.0021)
        self.path_K_PID = (0.0008, 0.00008, 0.003)
        
        #PID values of each circle, each element is a tuple (kp, ki, kd)
        self.circle_a_PID = (-0.7, -0.00045, -0.050)
        self.circle_b_PID = (-0.55, -0.00045, -0.037)
        self.circle_c_PID = (-0.56, -0.00045, -0.037)
        self.circle_d_PID = (-0.0005, -0.00045, -0.003)
        self.circle_e_PID = (-0.0030, -0.000045, -0.0017)
        self.circle_f_PID = (-0.050, -0.00045, -0.037)
        self.circle_g_PID = (-0.050, -0.00045, -0.037)
        self.circle_h_PID = (-0.050, -0.00045, -0.037)
        self.circle_i_PID = (-0.050, -0.00045, -0.037)
        self.circle_j_PID = (-0.050, -0.00045, -0.037)
        self.circle_k_PID = (-0.05, -0.06, -0.03)
        self.circle_l_PID = (-0.022, -0.002, -0.02)
        self.circle_m_PID = (-0.050, -0.00045, -0.037)
        self.circle_n_PID = (-0.050, -0.00045, -0.037)
        self.circle_o_PID = (-0.050, -0.00045, -0.037)
        self.circle_p_PID = (-0.070, -0.006, -0.005)
        self.circle_q_PID = (-0.050, -0.00045, -0.037)
        self.circle_r_PID = (-0.050, -0.00045, -0.037)
        self.circle_s_PID = (-0.050, -0.00045, -0.037)
        self.circle_t_PID = (-0.050, -0.00045, -0.037)
        self.circle_u_PID = (-0.050, -0.00045, -0.037)

    if ID == "limo795":
        #coordinates of every critical point
        self.lane_width = 450
        self.pt_a = (2933, -1980)
        self.pt_b = (3044, 2536)
        self.pt_c = (1922, -1977)
        self.pt_d = (1825, -652)
        self.pt_e = (2040, 2519)
        self.pt_f = (683, 2536)
        self.pt_g = (153, 287)
        self.pt_h = (413, 688)
        self.pt_i = (1560, -1945)
        self.pt_j = (-2017, -1933)
        self.pt_k = (-2003, 255)
        self.pt_l = (-2021, 823)
        self.pt_m = (-2006, 2597)
        self.pt_n = (-2412, -1788)
        self.pt_o = (-2402, 121)
        self.pt_p = (-2546, 686)
        self.pt_q = (-2408, 2522)
        self.pt_r = (-4683, -1980)
        self.pt_s = (-4737, 261)
        self.pt_t = (-4578, 683)
        self.pt_u = (-4660, 2654)

        #data points that characterize each circle for the corners - center x, center y, radius. Each variable is a tuple (A, B, C)
        self.circle_a = (self.pt_a[0] - self.lane_width, self.pt_a[1] + self.lane_width, self.lane_width/1.3)
        self.circle_b = (self.pt_b[0] - self.lane_width, self.pt_b[1] - self.lane_width, self.lane_width/1.5)
        self.circle_c = (self.pt_c[0] + self.lane_width, self.pt_c[1] + self.lane_width, self.lane_width/1.5)
        self.circle_d = (self.pt_d[0] + self.lane_width, self.pt_d[1] - self.lane_width, self.lane_width) #in practice this is not use
        self.circle_e = (self.pt_e[0] + self.lane_width, self.pt_e[1] - self.lane_width, self.lane_width/1.5)
        self.circle_f = (self.pt_f[0] + self.lane_width, self.pt_f[1] - self.lane_width, self.lane_width/2)
        self.circle_g = (self.pt_d[0] - self.lane_width, self.pt_d[1] - self.lane_width, self.lane_width)
        self.circle_h = (self.pt_h[0] - self.lane_width, self.pt_h[1] - self.lane_width, self.lane_width)
        self.circle_i = (self.pt_i[0] + self.lane_width, self.pt_i[1] + self.lane_width, self.lane_width)
        self.circle_j = (self.pt_j[0] + self.lane_width, self.pt_j[1] + self.lane_width, self.lane_width)
        self.circle_k = (self.pt_k[0] + self.lane_width*2.8, self.pt_k[1] - self.lane_width*2, self.lane_width*2)
        self.circle_l = (self.pt_l[0] + self.lane_width*2.4, self.pt_l[1] + self.lane_width*2.3, self.lane_width*1.7)
        self.circle_m = (self.pt_m[0] + self.lane_width, self.pt_m[1] - self.lane_width, self.lane_width)
        self.circle_n = (self.pt_n[0] - self.lane_width, self.pt_n[1] + self.lane_width, self.lane_width)
        self.circle_o = (self.pt_o[0] - self.lane_width*2.5, self.pt_o[1] - self.lane_width*2, self.lane_width*2)
        self.circle_p = (self.pt_p[0] - self.lane_width*2.3, self.pt_p[1] + self.lane_width*2.3, self.lane_width*1.9) #smaller multiplier to x increases x & decrease the multiplier to increase z
        self.circle_q = (self.pt_q[0] - self.lane_width, self.pt_q[1] - self.lane_width, self.lane_width)
        self.circle_r = (self.pt_r[0] + self.lane_width, self.pt_r[1] + self.lane_width, self.lane_width)
        self.circle_s = (self.pt_s[0] + self.lane_width, self.pt_s[1] - self.lane_width, self.lane_width)
        self.circle_t = (self.pt_t[0] + self.lane_width, self.pt_t[1] + self.lane_width, self.lane_width)
        self.circle_u = (self.pt_u[0] + self.lane_width, self.pt_u[1] - self.lane_width, self.lane_width)

        #the ranges near each corner that activates the circle path for the limo to follow
        self.act_range_a = (self.lane_width * 1, self.lane_width / 1.7)
        self.act_range_b = (self.lane_width * 0.8, self.lane_width * 1)
        self.act_range_c = (self.lane_width / 1, self.lane_width * 1)
        self.act_range_d = (self.lane_width * 0.7, self.lane_width * 0.5)
        self.act_range_e = (self.lane_width * 1, self.lane_width * 0.8)
        self.act_range_f = (self.lane_width * 1, self.lane_width*1.2)
        self.act_range_g = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_h = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_i = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_j = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_k = (self.lane_width * 1.4, self.lane_width * 1.4)
        self.act_range_l = (self.lane_width *1.4, self.lane_width *1.4)
        self.act_range_m = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_n = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_o = (self.lane_width * 1.4, self.lane_width * 1.4)
        self.act_range_p = (self.lane_width * 1.25, self.lane_width * 1.25)
        self.act_range_q = (self.lane_width * 1.3, self.lane_width * 1.3)
        self.act_range_r = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_s = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_t = (self.lane_width * 1.3, self.lane_width * 1.3)
        self.act_range_u = (self.lane_width * 1, self.lane_width * 1)

        #values of each line, each element is a tuple (kp, ki, kd)
        self.path_A_PID = (0.002, 0.00005, 0.003)
        self.path_B_PID = (0.0008, 0.00008, 0.003)
        self.path_C_PID = (0.0008, 0.00008, 0.005)
        self.path_D_PID = (0.0002, 0.00005, 0.001)
        self.path_D2_PID = (0.0007, 0.00008, 0.001)
        self.path_E_PID = (0.0005, 0.00003, 0.003)
        self.path_F_PID = (0.0008, 0.00008, 0.003)
        self.path_G_PID = (0.0006, 0.00007, 0.001)
        self.path_H_PID = (-0.0008, -0.0007, -0.001)
        self.path_I_PID = (-0.002, -0.00009, -0.001)
        self.path_J_PID =  (0.0008, 0.0008, 0.0008)
        self.path_K_PID = (0.0008, 0.00008, 0.003)
        
        #PID values of each circle, each element is a tuple (kp, ki, kd)
        self.circle_a_PID = (-0.7, -0.00045, -0.050)
        self.circle_b_PID = (-0.55, -0.00045, -0.037)
        self.circle_c_PID = (-0.56, -0.00045, -0.037)
        self.circle_d_PID = (-0.0005, -0.00045, -0.003)
        self.circle_e_PID = (-0.0030, -0.000045, -0.0017)
        self.circle_f_PID = (-0.050, -0.00045, -0.037)
        self.circle_g_PID = (-0.050, -0.00045, -0.037)
        self.circle_h_PID = (-0.050, -0.00045, -0.037)
        self.circle_i_PID = (-0.050, -0.00045, -0.037)
        self.circle_j_PID = (-0.050, -0.00045, -0.037)
        self.circle_k_PID = (-0.06, -0.00015, -0.01)
        self.circle_l_PID = (-0.032, -0.07, -0.02)
        self.circle_m_PID = (-0.050, -0.00045, -0.037)
        self.circle_n_PID = (-0.050, -0.00045, -0.037)
        self.circle_o_PID = (-0.050, -0.00045, -0.037)
        self.circle_p_PID = (-0.070, -0.006, -0.005)
        self.circle_q_PID = (-0.050, -0.00045, -0.037)
        self.circle_r_PID = (-0.050, -0.00045, -0.037)
        self.circle_s_PID = (-0.050, -0.00045, -0.037)
        self.circle_t_PID = (-0.050, -0.00045, -0.037)
        self.circle_u_PID = (-0.050, -0.00045, -0.037)
    
    if ID == "limo799":
        #coordinates of every critical point
        self.lane_width = 450
        self.pt_a = (2933, -1980)
        self.pt_b = (3044, 2536)
        self.pt_c = (1922, -1977)
        self.pt_d = (1825, -652)
        self.pt_e = (2040, 2519)
        self.pt_f = (683, 2536)
        self.pt_g = (153, 287)
        self.pt_h = (413, 688)
        self.pt_i = (1560, -1945)
        self.pt_j = (-2017, -1933)
        self.pt_k = (-2003, 255)
        self.pt_l = (-2021, 823)
        self.pt_m = (-2006, 2597)
        self.pt_n = (-2412, -1788)
        self.pt_o = (-2402, 121)
        self.pt_p = (-2546, 686)
        self.pt_q = (-2413, 2528)
        self.pt_r = (-4683, -1980)
        self.pt_s = (-4737, 261)
        self.pt_t = (-4578, 683)
        self.pt_u = (-4660, 2654)

        #data points that characterize each circle for the corners - center x, center y, radius. Each variable is a tuple (A, B, C)
        self.circle_a = (self.pt_a[0] - self.lane_width, self.pt_a[1] + self.lane_width, self.lane_width/1.3)
        self.circle_b = (self.pt_b[0] - self.lane_width, self.pt_b[1] - self.lane_width, self.lane_width/1.5)
        self.circle_c = (self.pt_c[0] + self.lane_width, self.pt_c[1] + self.lane_width, self.lane_width/1.5)
        self.circle_d = (self.pt_d[0] + self.lane_width, self.pt_d[1] - self.lane_width, self.lane_width) #in practice this is not use
        self.circle_e = (self.pt_e[0] + self.lane_width, self.pt_e[1] - self.lane_width, self.lane_width/1.5)
        self.circle_f = (self.pt_f[0] + self.lane_width, self.pt_f[1] - self.lane_width, self.lane_width/2)
        self.circle_g = (self.pt_d[0] - self.lane_width, self.pt_d[1] - self.lane_width, self.lane_width)
        self.circle_h = (self.pt_h[0] - self.lane_width, self.pt_h[1] - self.lane_width, self.lane_width)
        self.circle_i = (self.pt_i[0] + self.lane_width, self.pt_i[1] + self.lane_width, self.lane_width)
        self.circle_j = (self.pt_j[0] + self.lane_width, self.pt_j[1] + self.lane_width, self.lane_width)
        self.circle_k = (self.pt_k[0] + self.lane_width*2.8, self.pt_k[1] - self.lane_width*2, self.lane_width*2)
        self.circle_l = (self.pt_l[0] + self.lane_width*2.8, self.pt_l[1] + self.lane_width*2.8, self.lane_width*2.2)
        self.circle_m = (self.pt_m[0] + self.lane_width, self.pt_m[1] - self.lane_width, self.lane_width)
        self.circle_n = (self.pt_n[0] - self.lane_width, self.pt_n[1] + self.lane_width, self.lane_width)
        self.circle_o = (self.pt_o[0] - self.lane_width*2.9, self.pt_o[1] - self.lane_width*2, self.lane_width*2.1)
        self.circle_p = (self.pt_p[0] - self.lane_width*2.2, self.pt_p[1] + self.lane_width*2.2, self.lane_width*1.9) #smaller multiplier to x increases x & decrease the multiplier to increase z
        self.circle_q = (self.pt_q[0] - self.lane_width, self.pt_q[1] - self.lane_width, self.lane_width)
        self.circle_r = (self.pt_r[0] + self.lane_width, self.pt_r[1] + self.lane_width, self.lane_width)
        self.circle_s = (self.pt_s[0] + self.lane_width, self.pt_s[1] - self.lane_width, self.lane_width)
        self.circle_t = (self.pt_t[0] + self.lane_width, self.pt_t[1] + self.lane_width, self.lane_width)
        self.circle_u = (self.pt_u[0] + self.lane_width, self.pt_u[1] - self.lane_width, self.lane_width)

        #the ranges near each corner that activates the circle path for the limo to follow
        self.act_range_a = (self.lane_width * 1, self.lane_width / 1.7)
        self.act_range_b = (self.lane_width * 0.8, self.lane_width * 1)
        self.act_range_c = (self.lane_width / 1, self.lane_width * 1)
        self.act_range_d = (self.lane_width * 0.7, self.lane_width * 0.5)
        self.act_range_e = (self.lane_width * 1, self.lane_width * 0.8)
        self.act_range_f = (self.lane_width * 1, self.lane_width*1.2)
        self.act_range_g = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_h = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_i = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_j = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_k = (self.lane_width * 1.4, self.lane_width * 1.4)
        self.act_range_l = (self.lane_width *1, self.lane_width *1)
        self.act_range_m = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_n = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_o = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_p = (self.lane_width * 1.25, self.lane_width * 1.25)
        self.act_range_q = (self.lane_width * 1.3, self.lane_width * 1.3)
        self.act_range_r = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_s = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_t = (self.lane_width * 1.3, self.lane_width * 1.3)
        self.act_range_u = (self.lane_width * 1, self.lane_width * 1)


        #values of each line, each element is a tuple (kp, ki, kd)
        self.path_A_PID = (0.002, 0.00005, 0.003)
        self.path_B_PID = (0.0008, 0.00008, 0.003)
        self.path_C_PID = (0.0008, 0.00008, 0.005)
        self.path_D_PID = (0.0002, 0.00005, 0.001)
        self.path_D2_PID = (0.0007, 0.00008, 0.001)
        self.path_E_PID = (0.0005, 0.00003, 0.003)
        self.path_F_PID = (0.0008, 0.00008, 0.003)
        self.path_G_PID = (0.0003, 0.00011, 0.0009)
        self.path_H_PID = (-0.001, -0.00003, -0.001)
        self.path_I_PID = (-0.001, -0.00004, -0.0009)
        self.path_J_PID = (0.001, 0.00009, 0.0008)
        self.path_K_PID = (0.0008, 0.00008, 0.003)

        #PID values of each circle, each element is a tuple (kp, ki, kd)
        self.circle_a_PID = (-0.7, -0.00045, -0.050)
        self.circle_b_PID = (-0.55, -0.00045, -0.037)
        self.circle_c_PID = (-0.56, -0.00045, -0.037)
        self.circle_d_PID = (-0.0005, -0.00045, -0.003)
        self.circle_e_PID = (-0.0030, -0.000045, -0.0017)
        self.circle_f_PID = (-0.050, -0.00045, -0.037)
        self.circle_g_PID = (-0.050, -0.00045, -0.037)
        self.circle_h_PID = (-0.06, -0.09, -0.02)
        self.circle_i_PID = (-0.050, -0.00045, -0.037)
        self.circle_j_PID = (-0.050, -0.00045, -0.037)
        self.circle_k_PID = (-0.06, -0.00015, -0.01)
        self.circle_l_PID = (-0.01, -0.09, -0.01)
        self.circle_m_PID = (-0.06, -0.09, -0.02)
        self.circle_n_PID = (-0.050, -0.00045, -0.037)
        self.circle_o_PID = (-0.050, -0.03, -0.037)
        self.circle_p_PID = (-0.080, -0.02, -0.01)
        self.circle_q_PID = (-0.050, -0.009, -0.01)
        self.circle_r_PID = (-0.050, -0.00045, -0.037)
        self.circle_s_PID = (-0.050, -0.00045, -0.037)
        self.circle_t_PID = (-0.050, -0.00045, -0.037)
        self.circle_u_PID = (-0.050, -0.00045, -0.037)